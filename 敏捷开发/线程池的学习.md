# 线程池的学习

##### 线程池的简介

```
	线程池顾名思义就是实现创建若干个可以执行的线程放进一个池子（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。
```

##### 线程池的好处

```
1.降低资源的消耗
2.提高响应速度
3.提高线程的可管理性
```

##### 如何设计一个线程池

```java
1.线程池的核心参数
  a:corePoolSize         	线程池的核心线程数 
  b:maximumPoolSize			 	线程池的最大线程数
  c:keepAliveTime				 	线程空闲后的存活时间
  d:unit                 	时间单位
  e:workQueue            	用于存放任务的阻塞队列
  f:threadFactory        	用于创建线程的工厂类
  g:handler              	当队列和线程都满了之后的饱和策略
    
2.线程池的处理流程
  a:调用方提交任务
  b:确认线程池的核心线程数是否已经达到核心线程数的最大值，如果是将任务存入阻塞队列，如果不是就创建新线程执行任务。
  c:当任务存入阻塞队列时判断阻塞队列是否已满，如果满了就去判断当前线程数量是否已经达到线程池的最大线程数量限制，如果没满就将任务放进阻塞队列等候执行。
  d:当任务判断当前线程数量已经达到线程池的最大线程数量，按照确定的饱和策略处理多余的任务。如果没有达到最大线程的数量，就继续创建新的线程执行任务。
    
3.线程池的阻塞队列
  a:无界的队列      			初始化时不指定队列的容量
  b:有界的队列			 			初始化时不指定队列的容量
  c:同步移交的队列   		 队列本身不能存值，插入一个的同时必须删除一个
    
4.线程池的饱和策略
  a:AbortPolicy终止策略（默认）               直接抛出异常给调用方
  b:DiscardPolicy抛弃策略                    直接丢弃任务
  c:DiscardOlderstPolicy抛弃旧任务策略        丢弃一个旧的任务，然后执行一个新的任务
  d:CallerRunsPolicy调用方运行策略            线程池如果没有关闭，调用方自己本身起一个线程执行任务调用run方法
```

##### 常用的线程池

```java
1./**
   *线程数量无限的线程池
	 *newCachedThreadPool
   */
	public static ExcuterService newCachedThreadPool(){
  		return new ThreadPoolExecutor(0,Integer.Max_value, 60L,TimeUnit.SECONDS,new 	SynchronousQueue<Runable>());
	} 

2./**
   *线程数量固定的线程池
   *newFixedThreadPool
   */
  public static ExcuteService newFixedThreadPool(int nThreads){
  		return new ThreadPoolExecutor(nThreads, nThreads, 0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnadble>());
	}

3./**
   *单一线程的线程池
   *newSingleThreadExecutor
   */
   public static ExecutorService newSingleThreadExecutor(){
  		return new ThreadExecutorPool(1,1,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
}
```

向线程池提交任务的两种方法

```java

```

