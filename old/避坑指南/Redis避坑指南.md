# Redis避坑指南

##### 1.怎么正确的选择数据类型，让维护不再是噩梦

```java
1.几乎所有的数据都使用string去表示存在的问题
  a:浪费存储空间，key也是需要存储空间的
  b:管理和维护成为噩梦，Redis中存在着大量的KV对象
  c:Key的冲突几率变高（不同业务系统共用一个Redis服务）
	d:使用dict或者hash数据类型进行存储
2.Key的命令策略
  a:同一个Redis服务被公司中的各个业务线使用
    业务线名称+工程名+模块名+有意义的键名
3.常用的数据类型极其适用场景
  a:string-->应用最为广泛的数据类型，例如：计数器，session等键值”独立“的数据
  b:hash-->存储结构化（对象）的数据，KV共同构成一个对象的信息
  c:list-->队列、栈、有界队列
  d:set-->去重、无序的数据集合，在类似于社交的业务功能上有广泛应用，例如：共同关注、共同喜好、数据去重
  e:sortedset-->带有权重的集合，在类似于排行榜的业务上有广泛应用，且可以实现范围查找
```

##### 2.使用了事务，怎么没回滚呢？

```java
1.Redis事务基础：
	a:Redis事务的基础：（MULTI）(EXEC)(DISCARD)
	b:事务可以一次执行多个命令，并且带有以下两个重要的保证（单独的隔离操作）（原子操作）
2.Redis事务的两类错误
  a:事务在执行EXEC之前，入队的命令出错（命令语法错误）（服务器内存不足）--> Redis拒绝执行，自动放弃这个事务
  b:事务在执行EXEC调用之后失败（命令语法错误）--> 事务队列中的其他命令会继续执行，事务不会停止
3.为什么Redis不支持回滚
  a:Redis命令只会因为错误的语法而失败，或者是命令用在了错误类型的键上面
  b:因为不需要对回滚进行支持，所以Redis的内部可以保持简单且快速
  
```

##### 3.Redis性能上不去，可能因为是有Big Key

```java
1.Big Key以及造成的危害
  a:数据量大的Key,比如字符串Value值非常大（>10KB），哈希、列表、集合、有序集合元素过多（元素个数>5000个）
  b:Big Key造成的危害（内存分布不均-->Redis集群服务器的内存不一致）（超时阻塞-->单线程操作BIGKEY会消耗很多性能造成阻塞）（网络流量拥塞-->BIGKEY数据量大，占用大量网络带宽造成网络拥堵）（过期删除-->BITKEY数据量大，过期删除策略会消耗大量的性能造成阻塞）（迁移困难-->BIGKEY数据量大，迁移会比较慢）
2.Big Key的产生
  a:社交类场景--> 典型的是粉丝列表，对于明星或者大V来说，需要特殊的设计，否则就成为了Big Key
  b:汇总统计类场景--> 每天都会产生报表数据，报表数据汇总到一个Key里，日积月累就会变成Big Key
  c:日常缓存类场景--> 对DB中的数据进行缓存，大表（存在大字段）很可能会产生Big Key
3.如何发现Big Key
   a:redis-cli 提供了--bigkeys来查找bigkey.给出了每种数据结构的top one bigkey,同时给出了每种数据类型的键值个数以及平均大小.但是如果我想查询Redis中大于10KB的所有key,--bigkeys就无能为力。
   b:Redis 4.0开始提供memory usage命令可以计算每个键值的字节数。
3.删除Big Key 的方法
  a:string --> 可以直接用del命令，不会产生阻塞
  b:dict/hash --> 使用hscan命令每次获取部分field-value,在使用hdel删除每个field
  c:list --> 使用ltrim命令渐进式删除列表元素，直到把列表删除
  d:set --> 使用sscan命令，每次获取部分元素，在使用srem命令删除每个元素
  e:sortedset --> 使用zscan命令，每次获取部分元素，再使用zremrangebyrank命令删除元素
```

##### 4.Redis内存耗尽

```java
1.Redis服务器的内存会逐渐被耗尽
  a:业务不断发展，缓存数据不断增多，需要消耗Redis内存
  b:无效的（过期的）数据没有及时清理，需要消耗Redis内存
  c:没有对”冷数据“进行降级，需要消耗Redis内存
  d:Redis内存耗尽的结果是服务只能读，不能写
2.可以是用Expire命令将Key标记为Volatile的（易失的，有时效性的）
  a:使用Expire key seconds命令给key设置生存时间，当key过期时，它会被自动删除。
  b:如果一个命令只是修改一个带生存时间的key的值人不知用一个新的key值来代替它的，那么生存时间不会被改变
  c:使用Persist命令可以在不删除key的情况下，移除key的生存时间，让key变成一个持久的key
  d:可以对一个已经带有生存时间的key执行expire命令，新指定的生存时间会取代旧的生存时间
3.Redis的过期删除策略
  a:定时删除 --> 对于每一个设置了过期时间的key，都会创建一个定时器，一旦到达过期时间就立即删除
  b:惰性删除 --> 当访问一个key时，才判断该key是否过期，过期则删除
  c:定期删除 --> 每个一段时间，扫描Redis中过去key字典，并清除部分过期的key
  d:Redis同时使用了定期删除+惰性删除的策略保证不消耗大量内存，同时不浪费内存
```

##### 5.有了过期机制以后内存还不够用怎么办？

```java
1.内存不够用的产生原因
  a:业务缓存数据需求量大，占用大量的内存空间
  b:过期key虽然很多，但是不能”及时失效“，仍会有大量的key堆积在内存中，导致Redis内存耗尽
2.设置Redis的内存淘汰策略
  a:Redis的内存淘汰策略，是指内存达到maxmemory极限时，使用某种算法来处理掉哪些数据，以保证新数据的存入
  b:最常用的内存淘汰机制(noeviction)(allkeys-lru)(allkeys-random)(volatile-lru)(volatile-random)(volatile-ttl)
  c:总结(Volatile策略只会针对带过期时间的key进行淘汰)(Allkeys策略会对所有的key进行淘汰)
3.Redis的内存淘汰策略
  a:Redis会在每一次处理命令的时候判断当前是否达到了内存的最大限制，如果达到限制，则使用对应的算法去处理需要删除的key
  b:配置redis.conf(maxmemeory 最大内存限制)(maxmemory-policy 达到最大内存执行的内存策略)
  c:各种策略的选择
    1):如果你只是拿Redis做缓存，那应该使用allkeys下的淘汰策略
    2):如果你还想同时使用Redis的持久化功能，那就使用volatile下的淘汰策略
```

##### 6.如何解决频繁的命令往返造成的性能瓶颈

```java
1.Redis客户端与服务端的交互模型
  a:Redis是基于一个Request、一个Response的同步请求服务
  b:数据往返于两端的时间被称为RTT
2.Redis的pipeline的交互模型
  a:Redis客户端将多条命令一同发送给服务端，服务端执行完毕后一次性把执行结果返回给客户端。
  b:pipeline本质维持的是一个队列想，先进先出。
3.Redis pipeline与原生批量命令对比
  a:原生批量命令是原子性的，pipeline是非原子性的。
  b:原生批量命令一次只能执行一种命令，pipeline支持批量执行不同命令
  c:原生批量命令是服务端是实现的，而pipeline需要服务端与客户端共同完成
  d:Redis事务是具有隔离性的，在执行过程中不会穿插执行其他客户端发送的命令
```

##### 7.你配置好Redis持久化机制了吗

```java
1.为什么需要持久化
  a:高并发场景下只适用Redis作为存储设备，需要保证数据不会丢失
  b:通常的应用场景下虽然会同事把数据写入Mysql,但是直接从Mysql中恢复数据性能低下，且缺失选择性
2.Redis的持久化策略
  a:RDB
  b:AOF
3.RDB的持久化配置
  a:save --> 实践策略 save 300 10在100秒没执行过10次Redis指令就进行持久化
  b:dbfilename --> 文件名称 dbfilename dump.rdb
  c:dir --> 文件保存路径 dir /home/work/redis
  d:stop-writes-on-bgsave-error --> 如果持久化出错，主进程是否停止写入 yes/no
  e:rdbcompression --> 是否压缩 yes/no
  f:rdbchecksum --> 导入时是否检查 yes/no
4.RDB持久化的触发原理
  a:手动触发（save --> 会阻塞当前Redis服务器，直到持久化完成，线上应该禁止使用）（bgsave --> 该触发方式会fork 一个子进程，由子进程负责持久化过程，因此阻塞会发生在fork子进程的时候）
5.AOF的持久化策略
  a:appendonly --> 是否开启AOF  yes/no
  b:appendfilename --> 文件名称 ”appendonly.aof“
  c:appendfsync --> 同步方式 (everysec)(always)(no)
  d:no-appendfsync-on-rewrite --> aof重写期间是否同步 yes/no
  e:auto-aof-rewrite-percentage,auto-aof-rewrite-min-size,aof-rewrite-incremental-fsync --> 重写触发配置，文件重写策略
  f:aof-load-truncated --> 加载aof时如果有错如何处理 yes/no
6.AOF rewrite(重写)
  a:AOF重写定义 --> 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集
  b:触发机制 --> Redis会记录上次重写是的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64MB时触发
  e:重写原理 --> 将整个内存中的数据库内容用命令的方式重写了一个新的AOF文件，这点和快照有点类似
7.从持久化中回复数据
    Redis在启动是会去寻找是否存在AOF文件，存在就加载AOF文件然后启动，如果不存在就去寻找RDB文件，存在就加载RDB文件然后启动，如果不存在就启动一个空的Redis服务。
8.企业级的持久化配置策略
  a:如果只使用RDB --> 周期性的持久化数据，会丢失很多两次周期之间的数据
  b:如果只使用AOF --> 需要执行每一条指令恢复数据，速度慢，且AOF复杂备份和恢复机制可能存在BUG(RDB直接对数据快照，更加健壮)
  c:综合使用AOF和RDB两种持久化机制
```

##### 8.Redis的缓存穿透，缓存雪崩

```java
1.缓存穿透定义
  a:查询一个一定不存在的数据，如果规则是从数据库中查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库中查询
  b:当系统启动初期已经预置了数据，但是并未加载到Redis中，导致前端大量的请求由Mysql承担
  c:可以利用不存在的Key频繁攻击应用，流量大是，可能会是数据库宕机
2.解决缓存穿透的方法
  a:缓存预热 --> 系统上线后，提前将相关的缓存数据直接加载到缓存系统中
  b:如果查询数据库也为空，直接设置一个默认值（无意义的值）存方法哦缓存中，这样第二次到缓存中获取就有值了，而不会继续访问数据库(这个值最好设置过期时间)（同时在更新数据库操作这个值时及时更新缓存）
  c:在数据处理层，进行数据校验，判断数据类型和数据范围，直接过滤到这个请求不存在值的请求
  d:使用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉  false positive
 3.缓存雪崩的定义
   a:缓存服务宕机，导致所有的请求直接打到mysql数据库，造成数据库压力过大;或者是在同一时间缓存大面积的key过期
   b:瞬时请求都会被转发到mysql上，给后端数据库造成瞬时的负载升高的压力
   c:如果请求量增多，并发度变高，可能会是mysql压力过大二导致系统宕机
 4.解决缓存雪崩问题
   a:过期时间错开（可以再一个基础时间上增减一个随机值），避免热点数据几种失效
   b:本地缓存 + Hystrix限流&降级，避免数据访问压力过大
   c:开启Redis持久化机制，尽快回复Redis为可用状态
```

